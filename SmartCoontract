// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract SubscriptionPlatform is ReentrancyGuard {
    address public owner;
    uint256 public platformFee = 0.01 ether; // Default ETH fee
    uint256 public platformTokenFee = 10 * 10**18; // Default token fee
    uint256 public platformDuration = 30 days; // Default subscription duration
    uint256 public totalSubscribers;
    uint256 public gracePeriod = 7 days; // Grace period for expired subscriptions
    bool public paused = false;

    IERC20 public defaultPaymentToken;

    struct SubscriptionPlan {
        uint256 fee;
        uint256 tokenFee;
        uint256 duration;
        string metadata; // Detailed plan description
        string benefits; // Key benefits of the plan
    }

    struct SubscriptionRecord {
        address user;
        uint256 startTime;
        uint256 endTime;
        uint256 amountPaid;
        string paymentMethod; // e.g., "ETH" or "Token"
    }

    struct CreatorAnalytics {
        uint256 totalEarningsETH;
        uint256 totalEarningsTokens;
        uint256 activeSubscribers;
        uint256 totalSubscribers;
    }

    mapping(address => mapping(address => uint256)) public creatorSubscriptions; // creator -> user -> expiry
    mapping(address => bool) public creators;
    mapping(address => SubscriptionPlan[]) public creatorTiers; // creator -> subscription tiers
    mapping(address => CreatorAnalytics) public creatorAnalytics;
    mapping(address => SubscriptionRecord[]) public subscriptionHistory; // user -> history

    mapping(address => mapping(address => bool)) public autoRenewal; // creator -> user -> autoRenewal status
    mapping(address => bool) public whitelistedTokens; // Supported ERC20 tokens for payment
    mapping(address => mapping(address => uint256)) public suspendedSubscriptions; // creator -> user -> suspension end time

    event Subscribed(address indexed user, address indexed creator, uint256 expiry);
    event SubscribedWithToken(address indexed user, address indexed creator, uint256 expiry);
    event Withdrawn(address indexed owner, uint256 amount);
    event CreatorAdded(address indexed creator);
    event CreatorRemoved(address indexed creator);
    event PlanUpdated(
        address indexed creator,
        uint256 tierIndex,
        uint256 fee,
        uint256 tokenFee,
        uint256 duration,
        string metadata,
        string benefits
    );
    event AutoRenewalEnabled(address indexed creator, address indexed user);
    event AutoRenewalDisabled(address indexed creator, address indexed user);
    event SubscriptionSuspended(address indexed user, address indexed creator, uint256 suspensionTime);
    event SubscriptionReactivated(address indexed user, address indexed creator, uint256 expiry);
    event Paused();
    event Unpaused();

    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;
    }

    modifier onlyCreator() {
        require(creators[msg.sender], "Not a creator");
        _;
    }

    modifier notPaused() {
        require(!paused, "Contract is paused");
        _;
    }

    constructor(address _defaultTokenAddress) {
        owner = msg.sender;
        defaultPaymentToken = IERC20(_defaultTokenAddress);
        creators[msg.sender] = true;
    }

    // Subscription Functions
    function subscribe(address creator, uint256 tierIndex) external payable notPaused {
        require(creators[creator], "Invalid creator");
        require(tierIndex < creatorTiers[creator].length, "Invalid tier index");

        SubscriptionPlan memory plan = creatorTiers[creator][tierIndex];
        require(msg.value >= plan.fee, "Incorrect ETH payment");

        _processSubscription(creator, plan.duration, msg.value, 0, "ETH");

        emit Subscribed(msg.sender, creator, creatorSubscriptions[creator][msg.sender]);
    }

    function subscribeWithToken(
        address creator,
        uint256 tierIndex,
        address token,
        uint256 amount
    ) external notPaused {
        require(creators[creator], "Invalid creator");
        require(tierIndex < creatorTiers[creator].length, "Invalid tier index");
        require(whitelistedTokens[token], "Token not supported");

        SubscriptionPlan memory plan = creatorTiers[creator][tierIndex];
        require(amount >= plan.tokenFee, "Insufficient token amount");

        IERC20 paymentToken = IERC20(token);
        require(paymentToken.transferFrom(msg.sender, address(this), amount), "Token transfer failed");

        _processSubscription(creator, plan.duration, 0, amount, "Token");

        emit SubscribedWithToken(msg.sender, creator, creatorSubscriptions[creator][msg.sender]);
    }

    function enableAutoRenewal(address creator) external {
        autoRenewal[creator][msg.sender] = true;
        emit AutoRenewalEnabled(creator, msg.sender);
    }

    function disableAutoRenewal(address creator) external {
        autoRenewal[creator][msg.sender] = false;
        emit AutoRenewalDisabled(creator, msg.sender);
    }

    function suspendSubscription(address creator) external {
        require(creatorSubscriptions[creator][msg.sender] > block.timestamp, "No active subscription");
        suspendedSubscriptions[creator][msg.sender] = creatorSubscriptions[creator][msg.sender];
        creatorSubscriptions[creator][msg.sender] = 0; // Clear active subscription
        emit SubscriptionSuspended(msg.sender, creator, suspendedSubscriptions[creator][msg.sender]);
    }

    function reactivateSubscription(address creator) external {
        require(suspendedSubscriptions[creator][msg.sender] > 0, "No suspended subscription");
        creatorSubscriptions[creator][msg.sender] = suspendedSubscriptions[creator][msg.sender];
        suspendedSubscriptions[creator][msg.sender] = 0; // Clear suspension
        emit SubscriptionReactivated(msg.sender, creator, creatorSubscriptions[creator][msg.sender]);
    }

    function _processSubscription(
        address creator,
        uint256 duration,
        uint256 ethPaid,
        uint256 tokensPaid,
        string memory paymentMethod
    ) internal {
        if (block.timestamp >= creatorSubscriptions[creator][msg.sender]) {
            creatorAnalytics[creator].activeSubscribers += 1;
            creatorAnalytics[creator].totalSubscribers += 1;
        }

        uint256 newExpiry = block.timestamp > creatorSubscriptions[creator][msg.sender]
            ? block.timestamp + duration
            : creatorSubscriptions[creator][msg.sender] + duration;

        creatorSubscriptions[creator][msg.sender] = newExpiry;

        if (ethPaid > 0) {
            creatorAnalytics[creator].totalEarningsETH += ethPaid;
        }
        if (tokensPaid > 0) {
            creatorAnalytics[creator].totalEarningsTokens += tokensPaid;
        }

        // Record subscription history
        subscriptionHistory[msg.sender].push(
            SubscriptionRecord({
                user: msg.sender,
                startTime: block.timestamp,
                endTime: newExpiry,
                amountPaid: ethPaid > 0 ? ethPaid : tokensPaid,
                paymentMethod: paymentMethod
            })
        );
    }

    // Owner Functions
    function addCreator(address creator) external onlyOwner {
        creators[creator] = true;
        emit CreatorAdded(creator);
    }

    function removeCreator(address creator) external onlyOwner {
        creators[creator] = false;
        delete creatorSubscriptions[creator];
        delete creatorTiers[creator];
        emit CreatorRemoved(creator);
    }

    function updateCreatorPlan(
        uint256 tierIndex,
        uint256 fee,
        uint256 tokenFee,
        uint256 duration,
        string memory metadata,
        string memory benefits
    ) external onlyCreator {
        if (tierIndex < creatorTiers[msg.sender].length) {
            creatorTiers[msg.sender][tierIndex] = SubscriptionPlan(fee, tokenFee, duration, metadata, benefits);
        } else {
            creatorTiers[msg.sender].push(SubscriptionPlan(fee, tokenFee, duration, metadata, benefits));
        }
        emit PlanUpdated(msg.sender, tierIndex, fee, tokenFee, duration, metadata, benefits);
    }

    function addWhitelistedToken(address token) external onlyOwner {
        whitelistedTokens[token] = true;
    }

    function removeWhitelistedToken(address token) external onlyOwner {
        delete whitelistedTokens[token];
    }

    function pause() external onlyOwner {
        paused = true;
        emit Paused();
    }

    function unpause() external onlyOwner {
        paused = false;
        emit Unpaused();
    }
}
